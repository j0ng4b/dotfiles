#!/usr/bin/env sh

# Root dotfile directory
dotfiles_root=$(cd $(dirname $0); pwd)


# Helper functions
error() { echo "\033[31m[Error]\033[0m $1"; }
warn() { echo "\033[33m[Warning]\033[0m $1"; }
info() { echo "\033[32m[Info]\033[0m $1"; }

str_contains() {
    case $1 in
        *"$2"*) return 0 ;;
        *) return 1 ;;
    esac
}



# Target install directories
config_dir=${XDG_CONFIG_HOME:-$HOME/.config}
cache_dir=${XDG_CACHE_HOME:-$HOME/.cache}
state_dir=${XDG_STATE_HOME:-$HOME/.local/state}
data_dir=${XDG_DATA_HOME:-$HOME/.local/share}
home_dir=$HOME
bin_dir=$HOME/.local/bin

# Create the target directories if their not exists
for target in config cache state data bin; do
    eval target_dir=\$${target}_dir

    # Check if the target directory exists
    [ -d $target_dir ] && continue

    mkdir -p $target_dir
done


__get_dotfiles() {
    dotfiles=""

    for target in config data home bin; do
        for dotfile in $(ls $dotfiles_root/$target | tr '\n' ' '); do
            if ! str_contains "$dotfiles" "$dotfile"; then
                dotfiles="$dotfile $dotfiles"
            fi
        done
    done

    echo $dotfiles
}

# Action functions
__install_dotfile() {
    install_path=$1
    file_path=$2

    # Check if the file was installed
    [ -L $install_path ] && return 1

    ln -sfT $file_path $install_path
    return 0
}


__uninstall_dotfile() {
    uninstall_path=$1

    # Check if the file was not installed
    [ ! -L $uninstall_path ] && return 1

    rm -f $uninstall_path
    return 0
}


# Install files for a target of dotfile
__dotfile_action_target_files() {
    action=$1
    target=$2
    dotfile=$3
    dotfile_dir=$4

    # List of files to install
    files="$(ls $dotfile_dir | tr '\n' ' ')"

    action_result_error=0
    for file in $files; do
        file_path=$dotfile_dir/$file

        # Files of target `homeÂ´ has a lead dot at their names
        [ $target = "home" ] && file=.$file

        eval file_target_path=\$${target}_dir/$file

        # Act on the file
        eval __${action}_dotfile $file_target_path $file_path

        # Check for already (un)installed files
        action_result=$?
        if [ $action_result -gt 0 ]; then
            action_result_error=1
            warn "\`$file\` of '$dotfile' already ${action}ed!"
        fi
    done

    return $action_result_error
}


# Install the target of a dotfile
__dotfile_action_target() {
    action=$1
    target=$2
    dotfile=$3
    dotfile_dir=$4

    # Set install path
    eval dotfile_path=\$${target}_dir/$dotfile

    # Act on the file
    eval __${action}_dotfile $dotfile_path $dotfile_dir

    # Check for already (un)installed target
    action_result=$?
    if [ $action_result -gt 0 ]; then
        warn "\`$target\` of $dotfile already ${action}ed!!"
    fi

    return $action_result
}


__dotfile_action() {
    # How process the dotfile, i.e. installing or uninstalling it
    action=$1
    shift

    # List of dotfiles to act on
    dotfiles="$@"
    if [ -z "$dotfiles" ]; then
        warn "selecting all dotfiles...\n"
        dotfiles="$(__get_dotfiles)"
    fi

    # Act on dotfiles
    for dotfile in $dotfiles; do
        # Remove tail / if any
        dotfile="$(basename $dotfile)"
        if [ $action = "install" ]; then
            echo "Installing $dotfile..."
        else
            echo "Uninstalling $dotfile..."
        fi

        action_result=0
        found_dotfile=0
        for target in home config data bin; do
            # Root of the dotfile by target
            dotfile_dir=$dotfiles_root/$target/$dotfile
            if [ ! -d $dotfile_dir ]; then
                continue
            fi

            function=
            case $target in
                home | bin)    function=__dotfile_action_target_files ;;
                config | data) function=__dotfile_action_target ;;
            esac

            eval $function $action $target $dotfile $dotfile_dir
            found_dotfile=1
        done

        if [ $found_dotfile -eq 0 ]; then
            warn "The dotfile '$dotfile' doesn't exists! Skipping."
        fi
    done

    exit 0
}

_check_dependencies() {
    missing=0

    # Why the dotfile needs the command
    description=""
    desc() {
        description="$@"
    }

    # Commands that are needed to be installed to use the dotfile
    cmd() {
        if ! command -v $1 >/dev/null 2>&1; then
            error "The command '$1' is required by $dotfile"
            echo "  - because: $description"

            missing=1
        fi
    }

    # Optional dependencies
    opt() {
        if ! command -v $1 >/dev/null 2>&1; then
            warn "You may want install '$1' for $dotfile"
            echo "  - because: $description"
        fi
    }

    shift

    # List of dotfiles to act on
    dotfiles="$@"
    if [ -z "$dotfiles" ]; then
        warn "selecting all dotfiles...\n"
        dotfiles="$(__get_dotfiles)"
    fi

    # Act on dotfiles
    for dotfile in $dotfiles; do
        [ $dotfile = 'sysconf' ] && continue

        desc The dotfile requires the command thats it configure
        cmd $dotfile

        if [ $missing -eq 1 ]; then
            error "Missing the command thats $dotfile configures"
            continue
        fi

        # Load dependencies checks
        if [ -f "$dotfiles_root/.depends/$dotfile" ]; then
            . $dotfiles_root/.depends/$dotfile
        fi

        if [ $missing -eq 0 ]; then
            info "All $dotfile dependencies are satisfied."
        else
            error "Some dependencies are missing for $dotfile."
        fi
    done

    exit 0
}


[ $# -eq 0 ] && exit 1
while [ $# -gt 0 ]; do
    case $1 in
        install | uninstall)
            __dotfile_action $@ # no return
            ;;

        check)
            _check_dependencies $@ # no return
            ;;

        *)
            error "Unknowing command $1\n"
            exit 1
            ;;
    esac
done

