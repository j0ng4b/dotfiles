#!/usr/bin/env sh

# Create theme file if not exists
theme_file=${XDG_CONFIG_HOME:-$HOME/.config}/sysconf/theme
if [ ! -e "$theme_file" ]; then
    echo 'catppuccin' > $theme_file
fi


__generate_colors_file() {
    template_name=$1
    output_path=$2
    theme_name=$(cat $theme_file)

    if [ ! -e "$root/color_reloader/template/$template_name" ]; then
        warn "no template found for $template_name"
        return
    fi

    if [ ! -e "$root/color_reloader/color/$theme_name" ]; then
        error "theme file not found: $theme_name"
        return
    fi

    # Load theme colors
    . "$root/color_reloader/color/$theme_name"

    # Create
    mkdir -p $(dirname $output_path)

    # Generate color file
    cp --force "$root/color_reloader/template/$template_name" $output_path
    for color_name in base00 base01 base02 base03 base04 base05 base06 base07 base08 base09 base0A base0B base0C base0D base0E base0F; do
        eval "sed -i -e "s/{$color_name}/\${$color_name}/" "$output_path""
    done
}


_foot_reloader() {
    config_dir="$XDG_CONFIG_HOME/foot"
    colors_output_path="$config_dir/colors.ini"

    __generate_colors_file foot $colors_output_path

    # Update normal colors
    sed -nr 's/.*(regular|bright)([0-9])\s*=\s*([a-zA-Z0-9]{6}).*/\1 \2 \3/p' "$colors_output_path" |
        while read type num color; do
            [ "$type" = "bright" ] && num=$(($num + 8))
            printf "\033]4;$num;#$color\a"
        done

    # Update foreground color
    sed -nr 's/.*foreground\s*=\s*([a-zA-Z0-9]{6}).*/\1/p' "$colors_output_path" |
        while read color; do
            printf "\033]10;#$color\a"
        done

    # Update background color
    sed -nr 's/.*background\s*=\s*([a-zA-Z0-9]{6}).*/\1/p' "$colors_output_path" |
        while read color; do
            printf "\033]11;#$color\a"
        done
}

_cava_reloader() {
    config_dir="$XDG_CONFIG_HOME/cava"
    colors_output_path="$config_dir/config"

    if [ ! -e "$config_dir" ]; then
        mkdir -p "$config_dir"
    fi

    __generate_colors_file cava $colors_output_path
    pkill -USR1 cava
}

_btop_reloader() {
    config_dir="$XDG_CONFIG_HOME/btop/themes"
    colors_output_path="$config_dir/generated.theme"

    if [ ! -e "$config_dir" ]; then
        mkdir -p "$config_dir"
    fi

    __generate_colors_file btop $colors_output_path

    pkill -USR2 btop
}

_eww_reloader() {
    config_dir="$XDG_CONFIG_HOME/eww"
    colors_output_path="$config_dir/styles/colors.scss"

    __generate_colors_file eww $colors_output_path

    # NOTE: eww automatically reloads colors
}

_nvim_reloader() {
    theme_name=$(cat $theme_file)
    if [ -z "$theme_name" ]; then
        return
    fi

	for sock in "$XDG_RUNTIME_DIR"/nvim.*.0; do
		nvim --clean --headless --server "$sock" \
			--remote-send \
                "<Cmd>if get(g:, 'colors_name', '') !=# '$theme_name' |\
                    let g:_update_colorscheme=1                       |\
                    silent! colorscheme $theme_name                   |\
                endif<CR>" +'qa!' 2>/dev/null
	done
}

_tmux_reloader() {
    config_dir="$XDG_CONFIG_HOME/tmux"
    colors_output_path="$config_dir/colors.tmux"

    __generate_colors_file tmux $colors_output_path
    tmux run-shell "$config_dir/style.tmux"
}

_notification_reloader() {
    config_dir="$XDG_CONFIG_HOME/dunst/dunstrc.d"
    colors_output_path="$config_dir/colors.conf"

    __generate_colors_file dunst $colors_output_path

    # Workaround: for some reason on dunst 1.12.1 when reload config with
    # visible notifications hide notifications and any other notifications
    # aren't displayed.
    dunstctl set-paused true

    # If on config there are some notification with override_pause_level set to
    # 100 this loop will wait until it desapear to reload config.
    #
    # Ensuring that any configuration can't set override_pause_level to 100 this
    # can be simplified to only use sleep 0.01.
    while [ "$(dunstctl count displayed)" -gt 0 ]; do
        sleep 0.01
    done
    sleep 0.01

    dunstctl reload
}

_wm_reloader() {
    config_dir="$XDG_CONFIG_HOME/sway"
    colors_output_path="$config_dir/colors"

    __generate_colors_file sway $colors_output_path

    swaymsg reload

    # Update title colors
    focused=$(swaymsg -r -t get_seats | jq '.[0].focus')
    swaymsg -q "[con_id=${focused}]" title_format "<span rise='-5000' font_desc='Poppins 22'>\$dot_0\$dot_1\$dot_2</span>" &>/dev/null
}


main() {
    # List available re-loader
    reloaders_available="$(grep -o "^_.*_reloader" $root/$script)"

    # List already running re-loaders
    pid_files_list="$(ls /tmp/color_reloader.* 2>/dev/null)"
    if [ -n "$pid_files_list" ]; then
        reloaders_already_running=""
        for pid_file in $pid_files_list; do
            file_reloaders="$(sed -n '2p' $pid_file)"
            if ! str_contains "$reloaders_already_running" "$file_reloaders"; then
                file_reloaders="$pid_file%$file_reloaders"
                reloaders_already_running="$reloaders_already_running $file_reloaders"
            fi
        done
    fi

    # Check which re-loader should run
    reloaders=""
    while [ $# -gt 0 ]; do
        reloader="_$1_reloader"

        # Check if re-loader is already running
        reloader_running=""
        for reloader_list in $reloaders_already_running; do
            # Foot re-loader should start always
            [ "$1" = "foot" ] && continue

            if str_contains "$reloader_list" "$reloader"; then
                reloader_running=$(echo "$reloader_list" | cut -d'%' -f1)
                break
            fi
        done

        if [ -n "$reloader_running" ]; then
            pids=$(sed -n '3p' $reloader_running | cut -d' ' -f2-)
            pid1=$(echo $pids | cut -d' ' -f1)
            pid2=$(echo $pids | cut -d' ' -f2)

            # When some of pids are not running also kill other
            kill_pid1=$pid1
            kill_pid2=$pid2


            if kill -0 $pid1 2>/dev/null; then
                # When pid 1 is running do not also kill pid 2
                kill_pid2=''
            fi

            if kill -0 $pid2 2>/dev/null; then
                # When pid 2 is running do not also kill pid 1
                kill_pid1=''
            fi

            # Kill pids
            kill -9 $kill_pid1 $kill_pid2 2>/dev/null

            if [ -z "$kill_pid1" -a -z "$kill_pid2" ]; then
                warn "Re-loader \`$1\` already running! Skipped"

                shift
                continue
            else
                # Remove old file
                rm $reloader_running
            fi
        fi


        # Check if re-loader exit to be run
        if str_contains "$reloaders_available" "$reloader"; then
            reloaders="$reloader;$reloaders"
        else
            warn "Re-loader for \`$1\` not found! Skipped"
        fi

        shift
    done

    # If there're no re-loader to run then exit
    [ -z "$reloaders" ] && exit 0


    pid_file=$(mktemp /tmp/color_reloader.XXXXXXX) || exit 1
    while true; do
        eval "$reloaders"

        inotifywait --quiet --event modify "$theme_file" >/dev/null &

        # Copy inotifywait pid to stop if needed
        content="$(cat $pid_file)"
        if str_contains "$content" "$reloaders"; then
            sed -i "1s/.*/$!/" $pid_file
        else
            [ -n "$content" ] && content="\n$content"
            echo "$!\n$reloaders$content" > $pid_file
        fi

        # Wait until modify event finish or be stopped
        while kill -0 $! 2>/dev/null; do
            sleep 1
        done
    done &
    loop1=$!

    # Watch changes on theme file (symbolic link)
    while true; do
        inotifywait --quiet --event delete_self "$theme_file" | {
            while true; do
                sleep 0.5

                # Sometimes when the reloader deletes their file this loop keeps
                # running, break if the file does not exits.
                if [ ! -e $pid_file ]; then
                    break
                else
                    pid="$(cat $pid_file | head -n1)"
                fi

                if ! str_contains "$pid" "loops: "; then
                    # Kill old modify event watcher
                    kill -9 $pid 2>/dev/null

                    break
                fi
            done
        }
    done &
    loop2=$!

    echo "loops: $loop1 $loop2" >> $pid_file


    # To dynamic change foot colors its need to setup this script as shell of
    # it, below case check if foot re-loader is need the do the job.
    if str_contains "$reloaders" "_foot_reloader"; then
        exec "$SHELL"
    fi
}


main "$@"

