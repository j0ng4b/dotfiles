#!/usr/bin/env sh

# Create theme file if not exists
theme_file=${XDG_CONFIG_HOME:-$HOME/.config}/sysconf/theme
if [ ! -e "$theme_file" ]; then
    echo 'catppuccin' > $theme_file
fi


__generate_colors_file() {
    template_name=$1
    output_path=$2
    theme_name=$(cat $theme_file)

    if [ ! -e "$root/themes/templates/$template_name" ]; then
        warn "no template found for $template_name"
        return
    fi

    if [ -z "$theme_name" ]; then
        error "theme file not found: $theme_name"
        return
    fi

    # Load theme colors
    . "$root/themes/$theme_name"

    # Generate color file
    cp --force "$root/themes/templates/$template_name" $output_path
    for color_name in base00 base01 base02 base03 base04 base05 base06 base07 base08 base09 base0A base0B base0C base0D base0E base0F; do
        eval "sed -i -e "s/{$color_name}/\${$color_name}/" "$output_path""
    done
}


_foot_reloader() {
    config_dir="$XDG_CONFIG_HOME/foot"
    colors_output_path="$config_dir/colors.ini"

    __generate_colors_file foot $colors_output_path

    # Update normal colors
    sed -nr 's/.*(regular|bright)([0-9])\s*=\s*([a-zA-Z0-9]{6}).*/\1 \2 \3/p' "$colors_output_path" |
        while read type num color; do
            [ "$type" = "bright" ] && num=$(($num + 8))
            printf "\033]4;$num;#$color\a"
        done

    # Update foreground color
    sed -nr 's/.*foreground\s*=\s*([a-zA-Z0-9]{6}).*/\1/p' "$colors_output_path" |
        while read color; do
            printf "\033]10;#$color\a"
        done

    # Update background color
    sed -nr 's/.*background\s*=\s*([a-zA-Z0-9]{6}).*/\1/p' "$colors_output_path" |
        while read color; do
            printf "\033]11;#$color\a"
        done
}

_cava_reloader() {
    config_dir="$XDG_CONFIG_HOME/cava"
    colors_output_path="$config_dir/config"

    if [ ! -e "$config_dir" ]; then
        mkdir -p "$config_dir"
    fi

    __generate_colors_file cava $colors_output_path
    pkill -USR1 cava
}

_btop_reloader() {
    config_dir="$XDG_CONFIG_HOME/btop/themes"
    colors_output_path="$config_dir/generated.theme"

    if [ ! -e "$config_dir" ]; then
        mkdir -p "$config_dir"
    fi

    __generate_colors_file btop $colors_output_path

    pkill -USR2 btop
}

_eww_reloader() {
    config_dir="$XDG_CONFIG_HOME/eww"
    colors_output_path="$config_dir/styles/colors.scss"

    __generate_colors_file eww $colors_output_path

    # NOTE: eww automatically reloads colors
}

_nvim_reloader() {
    theme_name=$(cat $theme_file)
    if [ -z "$theme_name" ]; then
        return
    fi

	for sock in "$XDG_RUNTIME_DIR"/nvim.*.0; do
		nvim --clean --headless --server "$sock" \
			--remote-send \
                "<Cmd>if get(g:, 'colors_name', '') !=# '$theme_name' |\
                    let g:_update_colorscheme=1                       |\
                    silent! colorscheme $theme_name                   |\
                endif<CR>" +'qa!' 2>/dev/null
	done
}

_tmux_reloader() {
    config_dir="$XDG_CONFIG_HOME/tmux"
    colors_output_path="$config_dir/colors.tmux"

    __generate_colors_file tmux $colors_output_path
    tmux source-file "$config_dir/tmux.conf"
}

_wm_reloader() {
    config_dir="$XDG_CONFIG_HOME/sway"
    colors_output_path="$config_dir/colors"

    __generate_colors_file sway $colors_output_path
    swaymsg reload
}


main() {
    # List available re-loader
    reloaders_available="$(grep -o "^_.*_reloader" $root/$script)"

    # List already running re-loaders
    pid_files_list="$(ls /tmp/color_reloader.* 2>/dev/null)"
    if [ -n "$pid_files_list" ]; then
        reloaders_already_running="$(tail -qn 1 $pid_files_list)"
    fi

    # Check which re-loader should run
    reloaders=""
    while [ $# -gt 0 ]; do
        reloader="_$1_reloader"

        # Check if re-loader is already running
        reloader_running=""
        for reloader_list in $reloaders_already_running; do
            # Foot re-loader should start always
            [ "$1" = "foot" ] && continue

            if str_contains "$reloader_list" "$reloader"; then
                reloader_running=1
                break
            fi
        done

        if [ -n "$reloader_running" ]; then
            warn "Re-loader \`$1\` already running! Skipped"

            shift
            continue
        fi


        # Check if re-loader exit to be run
        if str_contains "$reloaders_available" "$reloader"; then
            reloaders="$reloader;$reloaders"
        else
            warn "Re-loader for \`$1\` not found! Skipped"
        fi

        shift
    done

    # If there're no re-loader to run then exit
    [ -z "$reloaders" ] && exit 0


    pid_file=$(mktemp /tmp/color_reloader.XXXXXXX) || exit 1
    while true; do
        eval "$reloaders"

        inotifywait --quiet --event modify "$theme_file" >/dev/null &

        # Copy inotifywait pid to stop if needed
        echo $! > $pid_file
        echo "$reloaders" >> $pid_file

        # Wait until modify event finish or be stopped
        while kill -0 $! 2>/dev/null; do
            sleep 1
        done
    done &

    # Watch changes on theme file (symbolic link)
    while true; do
        inotifywait --quiet --event delete_self "$theme_file" | {
            # Kill old modify event watcher
            kill -9 $(cat $pid_file) 2>/dev/null
        }
    done &


    # To dynamic change foot colors its need to setup this script as shell of
    # it, below case check if foot re-loader is need the do the job.
    if str_contains "$reloaders" "_foot_reloader"; then
        exec "$SHELL"
    fi
}


main "$@"

