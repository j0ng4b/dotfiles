////////////////////////////////////////////////////////////////////////////////
//  ╔═╗┌┐┌┬┌┬┐┌─┐┌┬┐┬┌─┐┌┐┌┌─┐
//  ╠═╣│││││││├─┤ │ ││ ││││└─┐
//  ╩ ╩┘└┘┴┴ ┴┴ ┴ ┴ ┴└─┘┘└┘└─┘
////////////////////////////////////////////////////////////////////////////////

animations {
    window-open {
        curve "linear"
        duration-ms 200
        custom-shader "
            vec4 open_color(vec3 coords_geo, vec3 size_geo) {
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                vec2 coords = (coords_geo.xy - vec2(0.5, 0.5)) * size_geo.xy * 2.0;
                coords = coords / length(size_geo.xy);

                float p = niri_clamped_progress;
                if (p * p <= dot(coords, coords))
                    color = vec4(0.0);

                return color * p;
            }
        "
    }

    window-resize {
        spring damping-ratio=0.50 stiffness=500 epsilon=0.00001
    }

    window-close {
        curve "linear"
        duration-ms 300
        custom-shader "
            vec4 close_color(vec3 coords_geo, vec3 size_geo) {
                // Simulate an accelerated fall: square the (linear) progress.
                float progress = niri_clamped_progress * niri_clamped_progress;

                // Get our rotation pivot point coordinates at the bottom center of the window.
                vec2 coords = (coords_geo.xy - vec2(0.5, 1.0)) * size_geo.xy;

                // Move the window down to simulate a fall.
                coords.y -= progress * 500.0;

                // Randomize rotation direction and maximum angle.
                float random = (niri_random_seed - 0.5) / 2.0;
                random = sign(random) - random;
                float max_angle = 0.5 * random;

                // Rotate the window around our pivot point.
                float angle = progress * max_angle;
                mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
                coords = rotate * coords;

                // Transform the coordinates back.
                coords_geo = vec3(coords / size_geo.xy + vec2(0.5, 1.0), 1.0);

                // Sample the window texture.
                vec3 coords_tex = niri_geo_to_tex * coords_geo;
                vec4 color = texture2D(niri_tex, coords_tex.st);

                // Multiply by alpha to fade out.
                return color * (1.0 - (niri_clamped_progress / 1.5));
            }
        "
    }

    window-movement {
        spring damping-ratio=0.65 stiffness=500 epsilon=0.00001
    }

    horizontal-view-movement {
        curve "ease-out-cubic"
        duration-ms 400
    }

    workspace-switch {
        spring damping-ratio=0.65 stiffness=500 epsilon=0.00001
    }

    overview-open-close {
        spring damping-ratio=0.60 stiffness=500 epsilon=0.00001
    }

    recent-windows-close {
        spring damping-ratio=0.60 stiffness=500 epsilon=0.00001
    }
}

